---
title: Parsers
date: '2022-01-15'
tags: ['coding']
image: ./logo.png
description: Let's understand how Parsers work!
draft: true
---

In the [last post](./abstract-syntax-trees), I looked at abstract syntax trees (ASTs).
In this post, I want to find out how ASTs are generated using a parser.
I am interested in the possibility to use a parser to create a language that outputs [rhythmical objects](./rhythmical-objects).

## What is a parser

Simply put, a parser reads a source language as text and outputs an AST.
The process involves

- a lexical analyzer that splits creates a list of tokens
- a syntactical analyzer that creates an AST from the list of tokens

Practically, a parser can be used as a basis to create any language you want.
Languages for specific purposes are called domain specific languages (DSLs).

## JS based DSLs for music

Let's look at some examples of JS based DSLs for music. There are already some out there. What I found:

- [tidal.pegjs](https://www.npmjs.com/package/tidal.pegjs), a parser for tidal style syntax
- [nested tuplets / nestup](https://github.com/cutelabnyc/nested-tuplets), a language for nested rhythms
- [in-seconds](https://github.com/danigb/in-seconds), convert musical expressions to seconds
- [sema](https://github.com/mimic-sussex/sema), live coding DSL

### tidal.pegjs

This library by [Charlie Roberts](https://github.com/charlieroberts) is able to parse [tidal style mini notation](http://tidalcycles.org/docs/reference/mini_notation/).
Apart from querying events directly, we can create an AST like this:

```js
import Pattern from 'tidal.pegjs/dist/pattern.js';

export const p = Pattern('[A [B C]]');
console.log(p.__data);
```

yields

import Pattern from 'tidal.pegjs/dist/pattern.js';
export const p = Pattern('[A [B C]]');

```json
{
  "type": "group",
  "values": [
    {
      "type": "string",
      "value": "A"
    },
    {
      "type": "group",
      "values": [
        {
          "type": "string",
          "value": "B"
        },
        {
          "type": "string",
          "value": "C"
        }
      ]
    }
  ]
}
```

The above AST is similar to unified ASTs with the only difference being the `values` prop for `children`.
We can transform any tree to unified structure using the following function

```js
import { curry } from 'ramda';

export const unify = curry((props, data) => {
  const {
    getChildren = (node) => node.children,
    getType = (node) => node.type,
    map = ({ type, data, children }) => ({ type, data, ...(children ? { children } : {}) }),
  } = props;
  const type = getType(data);
  const children = getChildren(data);
  if (!children) {
    return map({ type, data });
  }
  return map({
    type,
    data,
    children: children.map(unify(props)),
  });
});
```

In the case of the tree returned by tidal.pegjs, we can then do:

```js
export const unifyPatternData = (patternData: Pattern) => {
  return unify(
    {
      getChildren: (node) => node.values,
      map: ({ type, data: { value }, children }) => (children ? { type, children } : { type, value }),
    },
    patternData
  );
};

export const p = Pattern('[A [B C]]');
const ast = unifyPatternData(p.__data);

console.log('ast', ast);
```

Which creates the following diff:

import { unifyPattern, pData, pDataUnified } from '../components/tidal.pegjs/TidalSandbox.tsx';
import DiffViewer from '../components/common/DiffViewer';

<DiffViewer
  splitView={true}
  showDiffOnly={false}
  hideLineNumbers={false}
  {...{
    oldValue: JSON.stringify(pData, null, 2),
    newValue: JSON.stringify(pDataUnified, null, 2),
  }}
/>

The unified pattern can then also be visualized with [d3-hierarchy](https://github.com/d3/d3-hierarchy):

import Tree from '../components/rhythmical/components/Tree.tsx';
import { mapAST } from '../components/rhythmical/tree/rhythmAST.ts';

<Tree
  width={620}
  nodeRadius={10}
  dx={20}
  columns={[12, 12]}
  data={mapAST(pDataUnified, (node) => {
    return {
      ...node,
      name: node.value || '',
      color: node.type === 'group' ? 'steelblue' : 'tomato',
    };
  })}
  hideJson={true}
/>
